buildscript {
    apply from: 'dependencies.gradle'
}

plugins {
    id 'application'
//    id 'checkstyle'
    id 'com.diffplug.spotless' version "${spotlessVersion}"
    id 'antlr'
    id 'com.github.ben-manes.versions' version "${benmanesVersion}"
    // use: gradlew dependencyUpdates -Drevision=release
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
    sourceCompatibility = JavaVersion.VERSION_21
}

// store name of method parameter names in .class files (used to build
// DSL-adapter types, which contain the names of the parameters as members)
tasks.withType(JavaCompile).configureEach {
    configure(options) {
        options.compilerArgs << '-parameters'
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // LibGDX
    implementation supportDependencies.gdx
    implementation supportDependencies.gdx_freetype
    implementation supportDependencies.gdx_backend_lwjgl3
    implementation supportDependencies.gdx_lwjgl3_glfw_awt_macos
    implementation supportDependencies.gdx_platform
    implementation supportDependencies.gdx_freetype_platform
    implementation supportDependencies.gdx_ai

    // Gson
    implementation supportDependencies.gson

    // JUnit 4 and Mockito for testing
    testImplementation supportDependencies.junit
    testImplementation supportDependencies.mockito_core

    // ANTLR version 4 for DSL Grammar
    antlr supportDependencies.antlr
}

[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
sourceSets.main.java.srcDirs = ['game/src/', 'dungeon/src/', 'blockly/src/', "$projectDir/build/generated-src/"]
sourceSets.main.resources.srcDirs = ['game/assets/', 'dungeon/assets/', 'blockly/assets/']
sourceSets.test.resources.srcDirs = ['dungeon/assets/', 'game/test_resources', 'dungeon/test_resources']
sourceSets.test.java.srcDirs = ['game/test/', 'dungeon/test']
sourceSets.main.antlr.srcDirs = ['dungeon/src/dsl/antlr']

project.ext.mainClassName = 'starter.BasicStarter'
project.ext.assetsDir = new File('game/assets')

application {
    mainClass = project.mainClassName
}

tasks.register('runRandom', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'starter.RandomDungeon'
}

tasks.register('start', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'starter.Starter'
}

tasks.register('blockly', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'client.Client'
}

tasks.register('debug', JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    mainClass = project.mainClassName
    debug = true
}

test {
    testLogging {
        events 'passed', 'skipped', 'failed'
    }
}

//configurations.checkstyle {
//    resolutionStrategy.capabilitiesResolution.withCapability("com.google.collections:google-collections") {
//        select("com.google.guava:guava:0")
//    }
//}

//checkstyle {
//    project.ext.checkstyleVersion = '10.13.0'
//    project.ext.sevntuChecksVersion = '1.44.1'
//
//    repositories {
//        mavenLocal()
//        mavenCentral()
//        // we keep artifacts in maven central too,
//        // but this is just example of usage from our old maven repo on github
//        maven {
//            url "https://sevntu-checkstyle.github.com/sevntu.checkstyle/maven2"
//        }
//    }
//
//    ignoreFailures = true
//    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
//
//    //sourceSets = [sourceSets.main]
//    //showViolations = true
//    //reportsDir = file("$project.buildDir/checkstyleReports")
//    //configProperties = ['baseDir': "$project.projectDir"]
//
//    //https://discuss.gradle.org/t/some-checkstyle-rules-dont-work-in-gradle/16102/4
//    checkstyleMain {
//        source = sourceSets.main.allSource
//    }
//
//    configurations {
//        checkstyle
//    }
//
//    dependencies {
//        assert project.hasProperty("checkstyleVersion")
//
//        checkstyle "com.puppycrawl.tools:checkstyle:${checkstyleVersion}"
//        checkstyle "com.github.sevntu-checkstyle:sevntu-checks:${sevntuChecksVersion}"
//    }
//}

spotless {
    java {
        targetExclude('build/generated-src/**')
//        googleJavaFormat()
        eclipse()
//        eclipse().configFile(rootProject.file('config/eclipse-formatting.xml'))
    }
}

// generate ANTLR visitor and listener classes from grammar:
generateGrammarSource {
    maxHeapSize = '64m'
    arguments += ['-visitor', '-listener']
}

jar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    manifest {
        attributes 'Main-Class': project.mainClassName
    }

    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*module-info.class'
}

tasks.register('starterJar', Jar) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    manifest {
        attributes 'Main-Class': 'starter/Starter'
    }

    archiveFileName = 'Starter.jar'

    from sourceSets.main.output

    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*module-info.class'
}

// MANUAL TESTS:

tasks.register('runManualQuizTest', JavaExec) {
    mainClass = 'manual.quizquestion.QuizQuestionUITest'
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('runYesNoDialogTest', JavaExec) {
    mainClass = 'manual.YesNoDialogTest'
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('runCallbackTest', JavaExec) {
    mainClass = 'manual.quizquestion.CallbackTest'
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('runLoaderTest', JavaExec) {
    mainClass = 'manual.dslFileReader.DslFileReaderTest'
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('taskGenerationTest', JavaExec) {
    mainClass = 'manual.taskgeneration.TaskGenerationTest'
    classpath = sourceSets.test.runtimeClasspath
}

// Add default arguments to all JavaExec tasks:

tasks.withType(JavaExec).configureEach {
    dependsOn classes
    standardInput = System.in
    ignoreExitValue true
}
