package utils;

import java.io.*;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Logger;
import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;

/**
 * This class is used to run Java code generated by the Blockly language. It compiles the code
 * dynamically.
 *
 * <p>It uses the Java Compiler API to compile the code and then uses reflection to execute it. The
 * code is executed in a separate thread to avoid blocking the main thread. The class also provides
 * methods to check if the code is currently running and to stop the execution of the code.
 *
 * <p>This class is a singleton, meaning that there is only one instance of it in the application.
 *
 * @see server.Server Server
 */
public class BlocklyCodeRunner {

  private static final Logger LOGGER = Logger.getLogger(BlocklyCodeRunner.class.getSimpleName());
  private static BlocklyCodeRunner instance;

  /**
   * The name of the temporary folder where the compiled code will be stored. This folder is created
   * in the system's temporary directory. (default: "blockly")
   */
  public static String TEMP_FOLDER_NAME = "blockly";

  private static final int SLEEP_AFTER_EACH_LINE = 1; // seconds

  private static final String CodeWrapper =
      """
      import utils.BlocklyCommands;
      import utils.Direction;
      import core.level.utils.LevelElement;
      public class UserScript {
          public static void execute(BlocklyCommands hero) {
            %s
          }

          private static void sleep() {
            sleep(%d);
          }

          private static void sleep(int millis) {
            try {
              Thread.sleep(millis);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }

          private static void loadNextLevel() {
            contrib.level.DevDungeonLoader.loadNextLevel();
            sleep(1000);
          }

          private static void loadLevel(int index) {
            contrib.level.DevDungeonLoader.loadLevel(index);
            sleep(1000);
          }
      }
      """;

  private final AtomicBoolean codeRunning = new AtomicBoolean(false);
  private ExecutorService executor;
  private Future<?> currentExecution;

  private BlocklyCodeRunner() {} // private constructor for singleton

  /**
   * Returns the instance of the BlocklyCodeRunner.
   *
   * @return The instance of the BlocklyCodeRunner.
   */
  public static BlocklyCodeRunner instance() {
    if (instance == null) {
      instance = new BlocklyCodeRunner();
    }
    return instance;
  }

  /**
   * Execute the given java code.
   *
   * @param code Java code that should be executed.
   * @throws RuntimeException If an error occurs during execution.
   */
  public void executeJavaCode(String code) throws RuntimeException {
    code = addSleepCalls(code);
    codeRunning.set(true);
    code = String.format(CodeWrapper, code, SLEEP_AFTER_EACH_LINE);

    // In system temp directory
    Path tempDir = tempFolder();
    Path tempFile;
    if (tempDir == null) {
      return;
    }
    try {
      tempFile = tempDir.resolve("UserScript.java");
      Files.writeString(tempFile, code);
    } catch (IOException e) {
      return;
    }

    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    ByteArrayOutputStream errorStream = new ByteArrayOutputStream();

    int compilationResult = compiler.run(null, null, errorStream, tempFile.toFile().toString());

    if (compilationResult != 0) {
      String errors = errorStream.toString();
      System.err.println(errors);
      codeRunning.set(false);
      LOGGER.warning("Compilation error: " + errors);
      throw new RuntimeException("Compilation error:\n" + errors);
    }

    Class<?> scriptClass;
    Method method;
    try {
      URLClassLoader classLoader = new URLClassLoader(new URL[] {tempDir.toUri().toURL()});
      scriptClass = Class.forName("UserScript", true, classLoader);
      method = scriptClass.getMethod("execute", BlocklyCommands.class);
    } catch (ClassNotFoundException | NoSuchMethodException | MalformedURLException e) {
      LOGGER.warning("Error loading class or method: " + e.getMessage());
      codeRunning.set(false);
      throw new RuntimeException("Server error: " + e.getMessage());
    }

    executor = Executors.newSingleThreadExecutor();
    currentExecution =
        executor.submit(
            () -> {
              try {
                method.invoke(null, new BlocklyCommands());
                // Code executed successfully
                codeRunning.set(false);
              } catch (Exception e) {
                Throwable cause = e.getCause();
                String errorMessage = cause != null ? cause.getMessage() : e.getMessage();
                codeRunning.set(false);
                LOGGER.warning("Error executing code: " + errorMessage);
                throw new RuntimeException("Execution error: " + errorMessage);
              }
            });
  }

  /**
   * Checks if the code is currently running.
   *
   * @return true if the code is running, false otherwise.
   */
  public boolean isCodeRunning() {
    return codeRunning.get() && currentExecution != null && !currentExecution.isDone();
  }

  /**
   * Stops the currently running code.
   *
   * <p>This method will stop any code that is currently running. If the code is not running, it
   * will do nothing, but it will reset the codeRunning flag to false.
   */
  public void stopCode() {
    if (isCodeRunning()) {
      currentExecution.cancel(true);
      if (executor != null) {
        executor.shutdownNow();
      }
    }
    codeRunning.set(false);
  }

  /**
   * Inserts "sleep();" after each semicolon at the end of line.
   *
   * <p>It considers CRLF, LF, CR line breaks or end of string.
   *
   * @param code The Java code to modify.
   * @return The modified Java code with sleep calls added.
   */
  private String addSleepCalls(String code) {
    return code.replaceAll("(?<=;)(?=\\s*\\R|$)", " sleep();");
  }

  /**
   * Returns the path to the BlocklyCodeRunner's temporary folder.
   *
   * <p>If no temporary folder is found it will generate a new one in the system's temporary
   * directory.
   *
   * @return Path to the temporary folder. If no folder is found or cannot be created, returns null.
   */
  private Path tempFolder() {
    File tempDir = new File(System.getProperty("java.io.tmpdir"));
    File[] tempFiles = tempDir.listFiles();
    if (tempFiles != null) {
      for (File file : tempFiles) {
        if (file.isDirectory() && file.getName().equals(TEMP_FOLDER_NAME)) {
          return file.toPath();
        }
      }
    }

    // If no temp folder found, create a new one
    try {
      tempDir = Files.createDirectory(Paths.get(tempDir.getPath(), TEMP_FOLDER_NAME)).toFile();
    } catch (IOException e) {
      LOGGER.severe("Error creating temp folder: " + e.getMessage());
      return null;
    }
    return tempDir.toPath();
  }
}
