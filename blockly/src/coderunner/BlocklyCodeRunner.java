package coderunner;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;

/**
 * This class is used to run Java code generated by the Blockly language. It compiles the code
 * dynamically.
 *
 * <p>It uses the Java Compiler API to compile the code and then uses reflection to execute it. The
 * code is executed in a separate thread to avoid blocking the main thread. The class also provides
 * methods to check if the code is currently running and to stop the execution of the code.
 *
 * <p>This class is a singleton, meaning that there is only one instance of it in the application.
 *
 * @see server.Server Server
 */
public class BlocklyCodeRunner {

  private static final Logger LOGGER = Logger.getLogger(BlocklyCodeRunner.class.getSimpleName());
  private static BlocklyCodeRunner instance;

  /** List of whitelisted Blockly command method names without the trailing (); or parameters. */
  private static final List<String> WHITELIST =
      List.of(
          "hero.move",
          "hero.rotate",
          "hero.interact",
          "hero.pull",
          "hero.push",
          "hero.pickup",
          "hero.shootFireball",
          "hero.active",
          "hero.isNearTile",
          "hero.isNearComponent",
          "hero.dropItem",
          "hero.rest",
          "hero.checkBossViewDirection",
          "hero.moveToExit",
          "loadLevel",
          "loadNextLevel");

  /**
   * The name of the temporary folder where the compiled code will be stored. This folder is created
   * in the system's temporary directory. (default: "blockly")
   */
  public static String TEMP_FOLDER_NAME = "blockly";

  private static final int DEFAULT_SLEEP_AFTER_EACH_LINE = 0; // milliseconds

  private static final String CodeWrapper =
      """
      import coderunner.BlocklyCommands;
      import core.utils.Direction;
      import core.level.utils.LevelElement;
      import contrib.components.*;
      import components.*;
      import core.components.*;
      public class UserScript {
          public static void execute(BlocklyCommands hero) {
            %s
          }

          private static void sleep() {
            sleep(%d);
          }

          private static void sleep(int millis) {
            try {
              Thread.sleep(millis);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }

          private static void loadNextLevel() {
            core.level.loader.DungeonLoader.loadNextLevel();
            sleep(1000);
          }

          private static void loadLevel(int index) {
            core.level.loader.DungeonLoader.loadLevel(index);
            sleep(1000);
          }
      }
      """;

  private final AtomicBoolean codeRunning = new AtomicBoolean(false);
  private ExecutorService executor;
  private Future<?> currentExecution;

  private BlocklyCodeRunner() {} // private constructor for singleton

  /**
   * Returns the instance of the BlocklyCodeRunner.
   *
   * @return The instance of the BlocklyCodeRunner.
   */
  public static BlocklyCodeRunner instance() {
    if (instance == null) {
      instance = new BlocklyCodeRunner();
    }
    return instance;
  }

  /**
   * Execute the given java code.
   *
   * @param code Java code that should be executed.
   * @throws RuntimeException If an error occurs during execution.
   */
  public void executeJavaCode(String code) throws RuntimeException {
    executeJavaCode(code, DEFAULT_SLEEP_AFTER_EACH_LINE);
  }

  /**
   * Executes the given Java code.
   *
   * @param code Java code that should be executed.
   * @param sleepAfterEachLine The time to sleep after each line of code execution, in milliseconds.
   * @throws RuntimeException If an error occurs during execution.
   */
  public void executeJavaCode(String code, int sleepAfterEachLine) throws RuntimeException {
    if (sleepAfterEachLine > 0) code = addSleepCalls(code); // no sleep if time is 0
    codeRunning.set(true);
    code = String.format(CodeWrapper, code, sleepAfterEachLine);

    // In system temp directory
    Path tempDir = tempFolder();
    Path tempFile;
    if (tempDir == null) {
      return;
    }
    try {
      tempFile = tempDir.resolve("UserScript.java");
      Files.writeString(tempFile, code);
    } catch (IOException e) {
      return;
    }

    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    ByteArrayOutputStream errorStream = new ByteArrayOutputStream();

    int compilationResult = compiler.run(null, null, errorStream, tempFile.toFile().toString());

    if (compilationResult != 0) {
      String errors = errorStream.toString();
      System.err.println(errors);
      codeRunning.set(false);
      LOGGER.warning("Compilation error: " + errors);
      throw new RuntimeException("Compilation error:\n" + errors);
    }

    Class<?> scriptClass;
    Method method;
    try {
      URLClassLoader classLoader = new URLClassLoader(new URL[] {tempDir.toUri().toURL()});
      scriptClass = Class.forName("UserScript", true, classLoader);
      method = scriptClass.getMethod("execute", BlocklyCommands.class);
    } catch (ClassNotFoundException | NoSuchMethodException | MalformedURLException e) {
      LOGGER.warning("Error loading class or method: " + e.getMessage());
      codeRunning.set(false);
      throw new RuntimeException("Server error: " + e.getMessage());
    }

    executor = Executors.newSingleThreadExecutor();
    currentExecution =
        executor.submit(
            () -> {
              try {
                method.invoke(null, new BlocklyCommands());
                // Code executed successfully
                codeRunning.set(false);
              } catch (InvocationTargetException | IllegalAccessException e) {
                codeRunning.set(false);
                if (e.getCause() instanceof InterruptedException) {
                  return; // ignore interruption exception
                }

                String causeMessage =
                    e.getCause() != null ? e.getCause().getMessage() : e.getMessage();
                causeMessage = causeMessage != null ? causeMessage : e.toString();
                LOGGER.log(
                    Level.WARNING, String.format("Error executing code: %s", causeMessage), e);
                throw new RuntimeException("Execution error: " + causeMessage);
              }
            });
  }

  /**
   * Checks if the code is currently running.
   *
   * @return true if the code is running, false otherwise.
   */
  public boolean isCodeRunning() {
    return codeRunning.get() && currentExecution != null && !currentExecution.isDone();
  }

  /**
   * Stops the currently running code.
   *
   * <p>This method will stop any code that is currently running. If the code is not running, it
   * will do nothing, but it will reset the codeRunning flag to false.
   */
  public void stopCode() {
    if (isCodeRunning()) {
      currentExecution.cancel(true);
      if (executor != null) {
        executor.shutdownNow();
      }
    }
    codeRunning.set(false);
  }

  /**
   * Adds a "sleep();" call after each whitelisted Blockly command.
   *
   * <p>This method scans the provided Java code and appends "sleep();" after each occurrence of a
   * command from the WHITELIST. Only exact matches are modified. It preserves the original commands
   * and adds the sleep call directly after them on the same line.
   *
   * @param code The Java code to modify.
   * @return The modified Java code with sleep calls added.
   */
  private String addSleepCalls(String code) {
    for (String blocklyCommand : WHITELIST) {
      // "\\([^)]*\\);" matches any arguments in parentheses,
      // allowing any method parameters --> (any.parameters);
      String regex = Pattern.quote(blocklyCommand) + "\\([^)]*\\);";
      code = code.replaceAll(regex, "$0 sleep();");
    }
    return code;
  }

  /**
   * Returns the path to the BlocklyCodeRunner's temporary folder.
   *
   * <p>If no temporary folder is found it will generate a new one in the system's temporary
   * directory.
   *
   * @return Path to the temporary folder. If no folder is found or cannot be created, returns null.
   */
  private Path tempFolder() {
    File tempDir = new File(System.getProperty("java.io.tmpdir"));
    File[] tempFiles = tempDir.listFiles();
    if (tempFiles != null) {
      for (File file : tempFiles) {
        if (file.isDirectory() && file.getName().equals(TEMP_FOLDER_NAME)) {
          return file.toPath();
        }
      }
    }

    // If no temp folder found, create a new one
    try {
      tempDir = Files.createDirectory(Paths.get(tempDir.getPath(), TEMP_FOLDER_NAME)).toFile();
    } catch (IOException e) {
      LOGGER.severe("Error creating temp folder: " + e.getMessage());
      return null;
    }
    return tempDir.toPath();
  }
}
