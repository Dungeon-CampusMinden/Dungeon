



repositories {
    mavenCentral()
}

dependencies {
    implementation project(':dungeon'), 'com.github.javaparser:javaparser-symbol-solver-core:3.28.0'



    // JUnit 4 and Mockito for testing
    testImplementation supportDependencies.junit
    testRuntimeOnly supportDependencies.junitLauncher
}

sourceSets.main.java.srcDirs = ['src/', "$buildDir/generated-src/"]
sourceSets.main.resources.srcDirs = ['assets/']

sourceSets.test.java.srcDirs = ['test/']

processResources {
    from new File(project(':dungeon').projectDir, '/assets')
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}


tasks.withType(Jar) {
    // Das hier filtert ALLES, was im fertigen JAR landen würde
    exclude("**/*.xcf")
    exclude("**/debug/**")
    exclude("**/*.pdf") // Falls eine Library Dokumentation mitschleppt
}



tasks.register('runBlockly', JavaExec) {
    group = 'starter'
    mainClass = 'client.Client'
    classpath = sourceSets.main.runtimeClasspath
    def webFlag = project.hasProperty('web') ? project.property('web') : 'false'
    args "web=${webFlag}"

    standardOutput = System.out
    errorOutput = System.err
}

tasks.register("npmBuild", Exec) {
    group = 'build'
    workingDir = file("$projectDir/frontend")
    commandLine("npm.cmd", "run", "build")
}


tasks.named('jar', Jar) {
    dependsOn project(':dungeon').tasks.named('jar')
    dependsOn project(':dungeon').tasks.named('jar')
    archiveBaseName.set('Blockly')
    archiveFileName.set('Blockly.jar')

    from sourceSets.main.output
    from project(':dungeon').sourceSets.main.output

    from {
        configurations.runtimeClasspath.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }


    // Source für Language Server
    from(project(':dungeon').projectDir) {
        include 'src/core/level/utils/LevelElement.java'
        eachFile { it.path = it.path.replaceFirst('src/', '') }
        includeEmptyDirs = false
    }
    from(projectDir) {
        include 'src/core/utils/Direction.java'
        include 'src/coderunner/BlocklyCommands.java'
        eachFile { it.path = it.path.replaceFirst('src/', '') }
        includeEmptyDirs = false
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    manifest {
        attributes 'Main-Class': 'client.Client'
    }

    into('assets') {
        from project(':dungeon').file('assets')

        // Frontend-Build hinzufügen
        from projectDir.toPath().resolve('frontend/dist').toFile()
    }

    exclude('META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
}

def createJar(taskName, isWeb) {
    return tasks.register(taskName, Jar) {
        // Hier setzen wir den Namen (z.B. Blockly-web.jar oder Blockly-desktop.jar)
        archiveBaseName = 'Blockly'
        archiveClassifier = isWeb ? 'web' : 'desktop'

        // DAS WICHTIGSTE: Alle Abhängigkeiten laden
        dependsOn project(':dungeon').tasks.named('jar')

        // Code von beiden Projekten holen
        from sourceSets.main.output
        from project(':dungeon').sourceSets.main.output

        // Alle Libraries (Fat-JAR Logik)
        from {
            configurations.runtimeClasspath.collect {
                it.isDirectory() ? it : zipTree(it)
            }
        }

        // Deine Flag-Datei einbauen
        from(resources.text.fromString("web=${isWeb}")) {
            rename { "application.properties" }
        }

        // Die speziellen Java-Files für den Language Server
        from(project(':dungeon').projectDir) {
            include 'src/core/level/utils/LevelElement.java'
            eachFile { it.path = it.path.replaceFirst('src/', '') }
            includeEmptyDirs = false
        }
        from(projectDir) {
            include 'src/core/utils/Direction.java'
            include 'src/coderunner/BlocklyCommands.java'
            eachFile { it.path = it.path.replaceFirst('src/', '') }
            includeEmptyDirs = false
        }

        // Assets und Frontend einbinden
        into('assets') {
            from project(':dungeon').file('assets')
            from projectDir.toPath().resolve('frontend/dist').toFile()
        }

        // Sicherheit & Ordnung
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        exclude('META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')

        manifest {
            attributes 'Main-Class': 'client.Client'
        }
    }
}

// Wir registrieren die beiden Tasks
createJar("jarDesktop", false)
createJar("jarWeb", true)

// Optional: Mit 'build' beide gleichzeitig erstellen
artifacts {
    archives jarDesktop, jarWeb
}



tasks.named('test', Test) {
    useJUnitPlatform()
    failOnNoDiscoveredTests = false
}
