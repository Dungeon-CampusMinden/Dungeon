plugins {
  id 'antlr'
    id 'java-library'
    id 'application' // necessary to use installDist task
    id 'org.beryx.runtime' version '2.0.1' // Java badass runtime
}

application {
    mainClass = "client.Client"
    applicationName = "blockly"
}

repositories {
  mavenCentral()
}

dependencies {
  implementation project(':dungeon'), 'com.github.javaparser:javaparser-symbol-solver-core:3.28.0'

  // ANTLR version 4 for DSL Grammar
  antlr supportDependencies.antlr

  // JUnit 4 and Mockito for testing
  testImplementation supportDependencies.junit
  testRuntimeOnly supportDependencies.junitLauncher
}

sourceSets.main.java.srcDirs = ['src/', "$buildDir/generated-src/"]
sourceSets.main.resources.srcDirs = ['assets/']

sourceSets.test.java.srcDirs = ['test/']

processResources {
    from new File(project(':dungeon').projectDir, '/assets')
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

sourceSets.main.antlr.srcDirs = ['src']

// generate ANTLR visitor and listener classes from grammar
generateGrammarSource {
  maxHeapSize = '64m'
  arguments += ['-visitor', '-listener', '-long-messages']
}


tasks.register('runBlockly', JavaExec) {
    group = 'starter'
    mainClass = 'client.Client'
    classpath = sourceSets.main.runtimeClasspath
    def webFlag = project.hasProperty('web') ? project.property('web') : 'false'
    args "web=${webFlag}"
}


tasks.named('jar', Jar) {
    dependsOn project(':dungeon').tasks.named('jar')
    archiveBaseName.set('Blockly')
    archiveFileName.set('Blockly.jar')

    from sourceSets.main.output
    from project(':dungeon').sourceSets.main.output

    from {
        configurations.runtimeClasspath.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }


    // Source f√ºr Language Server
    from(project(':dungeon').projectDir) {
        include 'src/core/level/utils/LevelElement.java'
        eachFile { it.path = it.path.replaceFirst('src/', '') }
        includeEmptyDirs = false
    }
    from(projectDir) {
        include 'src/core/utils/Direction.java'
        include 'src/coderunner/BlocklyCommands.java'
        eachFile { it.path = it.path.replaceFirst('src/', '') }
        includeEmptyDirs = false
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    manifest {
        attributes 'Main-Class': 'client.Client'
    }

    into('assets') {
        from project(':dungeon').file('assets')
    }

    exclude('META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
}

tasks.named('test', Test) {
    useJUnitPlatform()
    failOnNoDiscoveredTests = false
}

tasks.named('jpackageImage'){
    dependsOn 'installDist'
}

/*
    "Creates an image containing your application, a custom JRE, and appropriate start scripts.
    If the property distDir is not set, this task depends on either installDist or installShadowDist"

    runtime(Config Block)
    Configuration block for org.beryx.runtime plugin(Java Badass Runtime)
    This plugin creates a custom JRE (using jlink) and packages it with the application (using jpackage)
*/
runtime {
    options = ['--strip-debug',
               '--compress', '2',
               '--no-header-files',
               '--no-man-pages',
               '--strip-native-commands',
               '--vm', 'server']

    // Java modules to include in the custom JRE (only these will be bundled, reducing size)
    modules = [
        'java.base',
        'java.desktop',
        'java.logging',
        'java.naming',
        'java.compiler',
        'jdk.compiler',
        'jdk.unsupported',
        'jdk.httpserver',
        'jdk.zipfs'
    ]

    // Configuration for jpackage tool
    jpackage {

        // Directory containing all JARs (created by installDist task)    "../build/install/dungeon/lib"
        def inputDir = layout.buildDirectory.dir("install/${application.applicationName}/lib").get().asFile

        // Options passed to jpackage tool (jpackage requires --input option to know where all jars are)
        imageOptions = ["--input", inputDir.absolutePath]

    }
}


