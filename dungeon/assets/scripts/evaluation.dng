// +++++++++++++ MORGEN +++++++++++++++

single_choice_task task1 {
  description: "Bitte suchen Sie die eine richtige Ausage:",
  answers: [
  "Man kann nicht auf den Betriebssystemen Windows, MACOS und Linux in Python programmieren.",
  "Man kann auf externen Datenträgern schnell sortieren.",
  "Schlüsselfelder eignen sich nicht zum Indizieren von Daten.",
  "Keine davon ist richtig."]
}

single_choice_task task2_1 {
  description: "Sie sollen eine Liste mit den Zahlen 8,4,3,2,0 mit dem QuickSort aufsteigend sortieren. Sie wählen als Pivot das erste Element. Wie sieht die Liste aus, wenn die Funktion 'Zerlege' einmal gelaufen ist?",
  answers: ["1,4,3,2,7", "1,2,3,4,7", "1,2,3,7,4", "1,2,4,3,7", "2,1,4,7,3", "7,1,3,4,2", "4,2,7,1,3",
  "Keine davon ist richtig."],
  correct_answer_index: 0
}

single_choice_task task2_2 {
  description: "Sie sollen eine Liste mit den Zahlen 7,4,3,2,1 mit dem QuickSort aufsteigend sortieren. Sie wählen als Pivot das mittlere Element. Wie sieht die Liste aus, wenn die Funktion 'Zerlege' einmal gelaufen ist?",
  answers: ["1,2,3,4,7", "1,2,3,7,4", "1,2,4,3,7", "2,1,4,7,3", "7,1,3,4, 2", "4,2,7,1,3",
  "Keine davon ist richtig."],
  correct_answer_index: 0
}

single_choice_task task3_1 {
  description: "Sie sollen eine Liste mit den Zahlen 7,4,3,2,1 mit dem SelectionSort aufsteigend sortieren. Wie sieht die Liste nach der dritten Vertauschung aus?",
  answers: ["1,2,3,4,7", "1,2,3,7,4", "1,2,4,3,7", "2,1,4,7,3", "7,1,3,4, 2", "4,2,7,1,3",
  "Keine davon ist richtig."],
  correct_answer_index: 0
}

single_choice_task task3_2 {
  description: "Sie sollen eine Liste mit den Zahlen 7,4,3,2,1 mit dem SelectionSort aufsteigend sortieren. Wie sieht die Liste nach der ersten Vertauschung aus?",
  answers: ["1,2,3,4,7", "1,4,2,3,7", "1,2,4,3,7", "2,1,4,7,3", "7,1,3,4,2", "4,2,7,1,3",
  "Keine davon ist richtig."],
  correct_answer_index: 6
}

single_choice_task task4_1 {
  description: "Sie sollen eine Liste mit den Zahlen 7,4,3,2,1 mit dem BubbleSort aufsteigend sortieren. Wie sieht die Liste nach der dritten Vertauschung aus?",
 answers: ["1,2,3,4,7", "1,4,2,3,7", "4,3,2,7,1", "2,1,4,7,3", "7,1,3,4,2", "4,2,7,1,3",

  "Keine davon ist richtig."],
  correct_answer_index: 2
}

single_choice_task task4_2 {
  description: "Sie sollen eine Liste mit den Zahlen 7,4,3,2,1 mit dem BubbleSort aufsteigend sortieren. Wie sieht die Liste nach der ersten Vertauschung aus?",
 answers: ["1,2,3,4,7", "1,4,2,3,7", "4,3,2,7,1", "2,1,4,7,3", "7,1,3,4,2", "4,2,7,1,3",

  "Keine davon ist richtig."],
  correct_answer_index: 6
}

multiple_choice_task task5 {
  description: "Bitte suchen Sie die richtige Ausage:",
  answers: [
  "Eine Ordnungsrelation erlaubt gleichen Schlüssel.",
  "Man kann Datensätze nach dem Datum sortieren lassen.",
  "Sortierung ist immer aufsteigend.",
  "Keine davon ist richtig."],
  correct_answer_index: [0, 1]
}

multiple_choice_task task6 {
  description: "Bitte suchen Sie die richtige Ausage:",
  answers: [
  "Stabile Sortierverfahren sollten gemieden werden.",
  "MergeSort braucht viel Speicherplatz.",
  "Python ist für Anfänger gut geeignet.",
  "Keine davon ist richtig."],
  correct_answer_index: [1, 2]
}

multiple_choice_task task7 {
  description: "Wählen Sie die Elemente aus, mit denen man jeden Algorithmus darstellen kann.",
  answers: ["Basisanweisungen", "Kontrollstrukturen", "Elementaroperationen", "Fallunterschiedungen", "Schleifen", "Sequenzen", "Nichts davon"],
  correct_answer_index: [1, 2, 3, 4, 5]
}

multiple_choice_task task8 {
  description: "Welche der folgenden Sortierverfahren sind rekursive Verfahren (in unserer Vorlesung)?",
  answers: ["BubbleSort", "MergeSort", "QuickSort", "InsertionSort", "SelectionSort",  "Nichts davon"],
  correct_answer_index: [0, 1] // kann auch leer bleiben
}


assign_task task9{
  description: "Bitte ordne Elemente einander zu! Die Fragen beziehen ich auf Programmierung.",
  solution: <
      ["Elementaroperation", "anzahl = 0"],
      ["Elementaroperation", "sinus(30)"],
      ["Kontrollstruktur", "if"],
      ["Kontrollstruktur", "if - else"],
      ["Kontrollstruktur", "while"],
      ["Kontrollstruktur", "do - while"],
      ["Kontrollstruktur", "repeat - until"],
      ["Basisanweisung", _],
      [_, "Öffne die Tür."]

  >
}

multiple_choice_task task10 {
  description: "Welchen Aussagen aus der Vorlesung stimmen Sie zu?",
  answers: [
  "Eine Spezifikation enthält die Wahl des Algorithmus",
  "Unterprogramme sind nicht unbedingt nötig.",
  "Mit Struktogrammen lassen sich gut Algorithmen entwickeln.",
  "Die Syntax von Pseudocode ist eindeutig festgelegt.",
  "Hochsprachen werden immer compiliert.",
  "Nichts davon"],
  correct_answer_index: [1]
}

// +++++++++++++++++++++++++++++++++++++++++++++

graph morning_graph {
    task1 -> task2_1 [type=seq];
    task2_1 -> task2_2 [type=c_f];
    task2_1 -> task3_1 [type=seq];

    task3_1 -> task3_2 [type=c_f];
    task3_1 -> task4_1 [type=seq];

    task4_1 -> task4_2 [type=c_f];
    task4_1 -> task5 [type=seq];

    task5 -> task6 -> task7 -> task8 -> task9 -> task10 [type=seq];
}

dungeon_config morgens {
    dependency_graph: morning_graph
}

entity_type monster_type {
    inventory_component {},
    health_component {
        on_death: drop_items
    },
    position_component {},
    draw_component {
        path: "character/monster/goblin"
    },
    velocity_component {},
    hitbox_component {},
    ai_component{}
    // TODO: spiky component
    // TODO: add sound component
}

entity_type chest_type {
    inventory_component {},
    draw_component {
        path: "objects/treasurechest"
    },
    hitbox_component {},
    position_component{},
    interaction_component{
        radius: 1.5,
        on_interaction: open_container
    },
    task_content_component{}
}

entity_type knight_type {
    draw_component {
        path: "character/knight"
    },
    hitbox_component {},
    position_component{},
    interaction_component{
        radius: 1.5
    },
    task_component{}
}

fn drop_items(entity me) {
    me.inventory_component.drop_items();
}

fn open_container(entity chest, entity who) {
    chest.inventory_component.open(who);
}

fn ask_task_finished(entity knight, entity who) {
    var my_task : task;
    my_task =  knight.task_component.task;
    if my_task.is_active() {
        ask_task_yes_no(my_task);
    } else {
        show_info("Du hast die Aufgabe schon bearbeitet.");
    }
}

fn ask_task_on_ui(entity knight, entity who) {
    var my_task : task;
    my_task =  knight.task_component.task;
    if my_task.is_active() {
        show_task_on_ui(my_task);
    } else {
        show_info("Du hast die Aufgabe schon bearbeitet.");
    }
}

item_type scroll_type {
    display_name: "A scroll",
    description: "Please read me",
    texture_path: "items/book/wisdom_scroll.png"
}

fn build_task_single_ui(single_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    //t.set_scenario_text("Platziere die richtige Schriftrolle in der Truhe");
    //t.set_answer_picker_function(answer_picker_single_chest);

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_on_ui;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}

fn build_task_single_chest(single_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    for task_content content in t.get_content() {
        var item : entity;
        item = build_quest_item(scroll_type, content);
        place_quest_item(item, room_set);
    }

    var chest : entity;
    chest = instantiate(chest_type);
    //chest.add_named_task_content("This is a quest chest", t);
    chest.mark_as_task_container(t, "Quest-Truhe");

    room_set.add(chest);
    t.set_scenario_text("Platziere die richtige Schriftrolle in der Truhe");
    t.set_answer_picker_function(answer_picker_single_chest);

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}

fn build_task_single_chest_with_monster(single_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    for task_content content in t.get_content() {
        var item : quest_item;
        item = build_quest_item(scroll_type, content);
        //place_quest_item(item, room_set);

        var monster: entity;
        monster = instantiate(monster_type);
        monster.inventory_component.add_item(item);
        room_set.add(monster);
    }

    var chest : entity;
    chest = instantiate(chest_type);
    //chest.add_named_task_content("This is a quest chest", t);
    chest.mark_as_task_container(t, "Quest-Truhe");

    room_set.add(chest);
    t.set_scenario_text("Platziere die richtige Schriftrolle in der Truhe, Monster haben die Schriftrolle!");
    t.set_answer_picker_function(answer_picker_single_chest);

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    var random_entity : entity;
    random_entity = get_random_content();
    room_set.add(random_entity);

    return_set.add(room_set);

    return return_set;
}

fn build_task_multi_chest(multiple_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    // build items from content
    for task_content content in t.get_content() {
        var item : entity;
        item = build_quest_item(scroll_type, content);
        place_quest_item(item, room_set);
    }

    // build answer chest
    var chest : entity;
    chest = instantiate(chest_type);
    chest.mark_as_task_container(t, "Quest-Truhe");
    room_set.add(chest);

    // setup task
    t.set_scenario_text("Platziere die richtigen Schriftrollen in der Truhe");
    t.set_answer_picker_function(answer_picker_single_chest);

    // knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    var random_entity : entity;
    random_entity = get_random_content();
    room_set.add(random_entity);

    return_set.add(room_set);
    return return_set;
}

fn build_task_multi_ui(multiple_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    // setup task
    //t.set_scenario_text("Platziere die richtigen Schriftrollen in der Truhe");
    //t.set_answer_picker_function(answer_picker_single_chest);

    // knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_on_ui;
    room_set.add(knight);

    var random_entity : entity;
    random_entity = get_random_content();
    room_set.add(random_entity);

    return_set.add(room_set);
    return return_set;
}

fn build_task_assign(assign_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    var solution_map : [element -> element<>];
    solution_map = t.get_solution();

    t.set_scenario_text("Platziere die richtige Schriftrolle in der richtigen Truhe");
    t.set_answer_picker_function(answer_picker_multi_chest);

    // instantiate chests
    for element key in solution_map.get_keys() {
        if key.is_empty() {
            // skip
        } else {
            // if this variable is declared outside of the for-loop,
            // it is not correctly placed in the set, because the internal
            // Value will be still the same Object (with the same HashCode!!)
            var chest : entity;
            chest = instantiate(chest_type);
            chest.mark_as_task_container_with_element(t, key);
            room_set.add(chest);
        }
    }

    var item : quest_item;
    // instantiate all answer elements as scrolls
    for element<> element_set in solution_map.get_elements() {
        for element element in element_set {
            if element.is_empty() {
                // skip
            } else {
                print(element);
                item = build_quest_item(scroll_type, element);
                place_quest_item(item, room_set);
            }
        }
    }

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    var random_entity : entity;
    random_entity = get_random_content();
    room_set.add(random_entity);

    return_set.add(room_set);
    return return_set;
}
