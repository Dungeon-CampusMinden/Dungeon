single_choice_task t1 {
    description: "3 ist die richtige Antwort!",
    answers: ["1", "2", "3"],
    correct_answer_index: 2
}

/*assign_task t2 {
    description: "AssignmentTask",
    solution: <["a", "b"], ["c", "d"], ["y", "x"], ["c", "hallo"], [_, "world"], ["!", _]>
}*/

assign_task t2 {
    description: "AssignmentTask, a->b, c->d",
    solution: <["a", "b"], ["c", "d"]>
}

multiple_choice_task t3 {
    description: "2 und 3 sind die richtige Antwort!",
    answers: ["1", "2", "3"],
    correct_answer_index: [1,2]
}

graph g {
    t1;
    t2;
    t3;
}

dungeon_config c {
    dependency_graph: g
}

entity_type chest_type {
    inventory_component {},
    draw_component {
        path: "objects/treasurechest"
    },
    hitbox_component {},
    position_component{},
    interaction_component{
        radius: 1.5,
        on_interaction: on_interact_chest
    },
    task_content_component{}
}

entity_type knight_type {
    draw_component {
        path: "character/knight"
    },
    hitbox_component {},
    position_component{},
    interaction_component{
        radius: 1.5,
        on_interaction: on_interact_knight
    },
    task_component{}
}

fn on_interact_chest(entity chest, entity who) {
    print("I AM BEING OPENED!!");
    chest.inventory_component.open(who);
}

fn on_interact_knight(entity knight, entity who) {
    // fÃ¼r sc/mc -> askOnHud/uiAnswerCallback -> Andre baut da was
    print("I AM BEING TALKED TO!!");

        var my_task : task;
        my_task =  knight.task_component.task;
        if my_task.is_active() {
            ask_task_yes_no(my_task); // -> askForFinishedTask(my_task);
            //show_task_on_ui(my_task); // -> askForFinishedTask(my_task);
        //askOnHud(task);
        } else {
            show_info("Du hast die Aufgabe schon bearbeitet.");
        }
}

item_type scroll_type {
    display_name: "A scroll",
    description: "Please read me",
    texture_path: "items/book/wisdom_scroll.png"
}

fn build_task(single_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    for task_content content in t.get_content() {
        var item : entity;
        item = build_quest_item(scroll_type, content);
        place_quest_item(item, room_set);
    }

    var chest : entity;
    chest = instantiate(chest_type);
    //chest.add_named_task_content("This is a quest chest", t);
    chest.mark_as_task_container(t, "Quest-Truhe");

    room_set.add(chest);
    t.set_scenario_text("Platziere die richtige Schriftrolle in der Truhe");
    t.set_answer_picker_function(answer_picker_single_chest);

    // knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}

fn build_task_multi(multiple_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    // build items from content
    for task_content content in t.get_content() {
        var item : entity;
        item = build_quest_item(scroll_type, content);
        place_quest_item(item, room_set);
    }

    // build answer chest
    var chest : entity;
    chest = instantiate(chest_type);
    chest.mark_as_task_container(t, "Quest-Truhe");
    room_set.add(chest);

    // setup task
    t.set_scenario_text("Platziere die richtigen Schriftrollen in der Truhe");
    t.set_answer_picker_function(answer_picker_single_chest);

    // knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}

fn build_task_assign(assign_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    var solution_map : [element -> element<>];
    solution_map = t.get_solution();

    t.set_scenario_text("Platziere die richtige Schriftrolle in der richtigen Truhe");
    t.set_answer_picker_function(answer_picker_multi_chest);

    // instantiate chests
    for element key in solution_map.get_keys() {
        if key.is_empty() {
            // skip
        } else {
            // if this variable is declared outside of the for-loop,
            // it is not correctly placed in the set, because the internal
            // Value will be still the same Object (with the same HashCode!!)
            var chest : entity;
            chest = instantiate(chest_type);
            chest.mark_as_task_container_with_element(t, key);
            room_set.add(chest);
        }
    }

    var item : quest_item;
    // instantiate all answer elements as scrolls
    for element<> element_set in solution_map.get_elements() {
        for element element in element_set {
            if element.is_empty() {
                // skip
            } else {
                print(element);
                item = build_quest_item(scroll_type, element);
                place_quest_item(item, room_set);
            }
        }
    }

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}
