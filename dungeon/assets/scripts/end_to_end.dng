single_choice_task t1 {
    description: "3 ist die richtige Antwort!",
    answers: ["1", "2", "3"],
    points: 3.0,
    points_to_pass: 1.0,
    correct_answer_index: 2
}

/*assign_task t2 {
    description: "AssignmentTask",
    solution: <["a", "b"], ["c", "d"], ["y", "x"], ["c", "hallo"], [_, "world"], ["!", _]>
}*/

assign_task t2 {
    description: "AssignmentTask, a->b, c->d",
    solution: <["a", "b"], ["c", "d"]>
}

multiple_choice_task t3 {
    description: "2 und 3 sind die richtige Antwort!",
    answers: ["1", "2", "3"],
    correct_answer_index: [1,2]
}

graph g {
    t1 -> t2 [type=c_c];
    t1 -> t3 [type=c_f];
}

dungeon_config c {
    dependency_graph: g
}

entity_type monster_type {
    inventory_component {},
    health_component {
        on_death: drop_items
    },
    position_component {},
    draw_component {
        path: "character/monster/goblin"
    },
    velocity_component {},
    hitbox_component {},
    ai_component{}
    // TODO: spiky component
    // TODO: add sound component
}

entity_type chest_type {
    inventory_component {},
    draw_component {
        path: "objects/treasurechest"
    },
    hitbox_component {},
    position_component{},
    interaction_component{
        radius: 1.5,
        on_interaction: open_container
    },
    task_content_component{}
}

entity_type knight_type {
    draw_component {
        path: "character/knight"
    },
    hitbox_component {},
    position_component{},
    interaction_component{
        radius: 1.5//,
        //on_interaction: ask_task_finished
    },
    task_component{}
}

fn drop_items(entity me) {
    me.inventory_component.drop_items();
}

fn open_container(entity chest, entity who) {
    chest.inventory_component.open(who);
}

fn ask_task_finished(entity knight, entity who) {
    var my_task : task;
    my_task =  knight.task_component.task;
    if my_task.is_active() {
        ask_task_yes_no(my_task);
    } else {
        show_info("Du hast die Aufgabe schon bearbeitet.");
    }
}

fn ask_task_on_ui(entity knight, entity who) {
    var my_task : task;
    my_task =  knight.task_component.task;
    if my_task.is_active() {
        show_task_on_ui(my_task);
    } else {
        show_info("Du hast die Aufgabe schon bearbeitet.");
    }
}

item_type scroll_type {
    display_name: "A scroll",
    description: "Please read me",
    texture_path: "items/book/wisdom_scroll.png"
}

/*
fn build_task_single_ui(single_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    //t.set_scenario_text("Platziere die richtige Schriftrolle in der Truhe");
    //t.set_answer_picker_function(answer_picker_single_chest);

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_on_ui;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}
*/

/*
fn build_task_single_chest(single_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    for task_content content in t.get_content() {
        var item : entity;
        item = build_quest_item(scroll_type, content);
        place_quest_item(item, room_set);
    }

    var chest : entity;
    chest = instantiate(chest_type);
    //chest.add_named_task_content("This is a quest chest", t);
    chest.mark_as_task_container(t, "Quest-Truhe");

    room_set.add(chest);
    t.set_scenario_text("Platziere die richtige Schriftrolle in der Truhe");
    t.set_answer_picker_function(answer_picker_single_chest);

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}
*/

fn build_task_single_chest_with_monster(single_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    for task_content content in t.get_content() {
        var item : quest_item;
        item = build_quest_item(scroll_type, content);
        //place_quest_item(item, room_set);

        var monster: entity;
        monster = instantiate(monster_type);
        monster.inventory_component.add_item(item);
        // TODO: should drop inventory on floor on death
        room_set.add(monster);
    }

    var chest : entity;
    chest = instantiate(chest_type);
    //chest.add_named_task_content("This is a quest chest", t);
    chest.mark_as_task_container(t, "Quest-Truhe");

    room_set.add(chest);
    t.set_scenario_text("Platziere die richtige Schriftrolle in der Truhe, Monster haben die Schriftrolle!");
    t.set_answer_picker_function(answer_picker_single_chest);

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}

fn build_task_multi_chest(multiple_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    // build items from content
    for task_content content in t.get_content() {
        var item : entity;
        item = build_quest_item(scroll_type, content);
        place_quest_item(item, room_set);
    }

    // build answer chest
    var chest : entity;
    chest = instantiate(chest_type);
    chest.mark_as_task_container(t, "Quest-Truhe");
    room_set.add(chest);

    // setup task
    t.set_scenario_text("Platziere die richtigen Schriftrollen in der Truhe");
    t.set_answer_picker_function(answer_picker_single_chest);

    // knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}

fn build_task_multi_ui(multiple_choice_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    // setup task
    //t.set_scenario_text("Platziere die richtigen Schriftrollen in der Truhe");
    //t.set_answer_picker_function(answer_picker_single_chest);

    // knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    knight.interaction_component.on_interaction = ask_task_on_ui;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}

fn build_task_assign(assign_task t) -> entity<><> {
    var return_set : entity<><>;
    var room_set : entity<>;

    var solution_map : [element -> element<>];
    solution_map = t.get_solution();

    t.set_scenario_text("Platziere die richtige Schriftrolle in der richtigen Truhe");
    t.set_answer_picker_function(answer_picker_multi_chest);

    // instantiate chests
    for element key in solution_map.get_keys() {
        if key.is_empty() {
            // skip
        } else {
            // if this variable is declared outside of the for-loop,
            // it is not correctly placed in the set, because the internal
            // Value will be still the same Object (with the same HashCode!!)
            var chest : entity;
            chest = instantiate(chest_type);
            chest.mark_as_task_container_with_element(t, key);
            room_set.add(chest);
        }
    }

    var item : quest_item;
    // instantiate all answer elements as scrolls
    for element<> element_set in solution_map.get_elements() {
        for element element in element_set {
            if element.is_empty() {
                // skip
            } else {
                print(element);
                item = build_quest_item(scroll_type, element);
                place_quest_item(item, room_set);
            }
        }
    }

    // quest giver knight
    var knight : entity;
    knight = instantiate_named(knight_type, "I am the knight");
    knight.task_component.task = t;
    // this does not work! why?
    knight.interaction_component.on_interaction = ask_task_finished;
    room_set.add(knight);

    return_set.add(room_set);
    return return_set;
}
