plugins {
    id 'java-library'
    id 'antlr'
}


dependencies {
    api project(':game')

    // LibGDX: expose this API to users because of core.level.elements.ILevel
    api supportDependencies.gdx
    api supportDependencies.gdx_platform
    api supportDependencies.gdx_backend_lwjgl3
    api supportDependencies.gdx_lwjgl3_glfw_awt_macos
    api supportDependencies.gdx_ai
    api supportDependencies.gdx_freetype
    api supportDependencies.gdx_freetype_platform

    // ANTLR version 4 for DSL Grammar
    antlr supportDependencies.antlr

    // JUnit 4 and Mockito for testing
    testImplementation supportDependencies.junit
    testImplementation supportDependencies.mockito_core
}


sourceSets.main.java.srcDirs = ['src/', "$projectDir/build/generated-src/antlr/main/"]
sourceSets.main.resources.srcDirs = ['assets/']

sourceSets.test.java.srcDirs = ['test/']
sourceSets.test.resources.srcDirs = ['test_resources/']

sourceSets.main.antlr.srcDirs = ['src/dsl/antlr']

processResources {
    from new File(project(':game').projectDir, '/assets')
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}


// store name of method parameter names in .class files (used to build
// DSL-adapter types, which contain the names of the parameters as members)
tasks.withType(JavaCompile).configureEach {
    configure(options) {
        options.compilerArgs << '-parameters'
    }
}

// generate ANTLR visitor and listener classes from grammar
generateGrammarSource {
    maxHeapSize = '64m'
    arguments += ['-visitor', '-listener']
}


// start the dungeon (different configurations)
tasks.register('runStarter', JavaExec) {
    mainClass = 'starter.Starter'
    classpath = sourceSets.main.runtimeClasspath
}

tasks.register('runRandomDungeon', JavaExec) {
    mainClass = 'starter.RandomDungeon'
    classpath = sourceSets.main.runtimeClasspath
}

tasks.register('runRoomBasedDungeon', JavaExec) {
    mainClass = 'starter.RoomBasedDungeon'
    classpath = sourceSets.main.runtimeClasspath
}


// Generate license report
import com.github.jk1.license.render.*

licenseReport {
    unionParentPomLicenses = true

    outputDir = "${rootProject.project('dungeon').buildDir}/licenses"

    // For game and dungeon dependencies (default is 'all projects'):
    projects = [rootProject.project('game'), rootProject.project('dungeon')]

    configurations = ['runtimeClasspath']

    excludeOwnGroup = true

    excludeBoms = false

    renderers = [new InventoryMarkdownReportRenderer('third-party-licenses.md', 'Back-End Libraries')]
}

// Create our Starter.jar
tasks.register('buildStarterJar', Jar) {
    // Generate license report first ...
    // Path: dungeon/build/licenses/

    dependsOn generateLicenseReport, ':game:build'

    manifest {
        attributes 'Main-Class': 'starter.Starter'
    }
    archiveFileName = 'Starter.jar'

    from "${rootProject.project('dungeon').buildDir}/licenses"
    from sourceSets.main.output
    from project(':game').sourceSets.main.output
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*module-info.class'
}


// some manual tests (wtf? this should be real tests! to be removed.)
tasks.register('runCallbackTest', JavaExec) {
    mainClass = 'manual.quizquestion.CallbackTest'
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('runManualQuizTest', JavaExec) {
    mainClass = 'manual.quizquestion.QuizQuestionUITest'
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('runTaskGenerationTest', JavaExec) {
    mainClass = 'manual.taskgeneration.TaskGenerationTest'
    classpath = sourceSets.test.runtimeClasspath
}

tasks.register('runYesNoDialogTest', JavaExec) {
    mainClass = 'manual.YesNoDialogTest'
    classpath = sourceSets.test.runtimeClasspath
}
