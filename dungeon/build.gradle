plugins {
    id 'java-library'
}


dependencies {
    api project(':game')

    // LibGDX: expose this API to users because of core.level.elements.ILevel
    api supportDependencies.gdx
    api supportDependencies.gdx_platform
    api supportDependencies.gdx_backend_lwjgl3
    api supportDependencies.gdx_lwjgl3_glfw_awt_macos
    api supportDependencies.gdx_ai
    api supportDependencies.gdx_freetype
    api supportDependencies.gdx_freetype_platform

    // JUnit and Mockito for testing
    testImplementation supportDependencies.junit
    testRuntimeOnly supportDependencies.junitLauncher
    testImplementation supportDependencies.mockito_core
}


sourceSets.main.java.srcDirs = ['src/']
sourceSets.main.resources.srcDirs = ['assets/']

sourceSets.test.java.srcDirs = ['test/']
sourceSets.test.resources.srcDirs = ['test_resources/']

processResources {
    from new File(project(':game').projectDir, '/assets')
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}


// start the dungeon (different configurations)
tasks.register('runRandomDungeon', JavaExec) {
    mainClass = 'starter.RandomDungeon'
    classpath = sourceSets.main.runtimeClasspath
}

tasks.register('runRoomBasedDungeon', JavaExec) {
    mainClass = 'starter.RoomBasedDungeon'
    classpath = sourceSets.main.runtimeClasspath
}


// create our Starter.jar
tasks.register('buildStarterJar', Jar) {
    dependsOn ':game:build'

    manifest {
        attributes 'Main-Class': 'starter.Starter'
    }
    archiveFileName = 'Starter.jar'

    from sourceSets.main.output
    from project(':game').sourceSets.main.output
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*module-info.class'
}


tasks.named('test', Test) {
    useJUnitPlatform()
}
