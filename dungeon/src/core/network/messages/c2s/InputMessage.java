package core.network.messages.c2s;

import core.Game;
import core.game.ECSManagement;
import core.network.messages.NetworkMessage;
import core.utils.Point;
import core.utils.Vector2;
import core.utils.logging.DungeonLogger;
import java.io.Serial;

/**
 * Clientâ†’server: Player input (e.g., movement, skill use, interaction).
 *
 * @param sessionId the session ID of the client sending the input
 * @param clientTick the client tick when the input was generated
 * @param sequence the sequence number of this input message (monotonically increasing per client)
 * @param action the action (e.g., move, move path, cast skill, interact)
 * @param point the point (e.g., move path, cast skill, interact) Can be null depending on action
 */
public record InputMessage(
    // HEADER
    int sessionId,
    int clientTick,
    short sequence,
    // PAYLOAD
    Action action,
    Point point // Optional, depending on action
    ) implements NetworkMessage {
  @Serial private static final long serialVersionUID = 1L;
  private static final DungeonLogger LOGGER = DungeonLogger.getLogger(InputMessage.class);

  private static short currentSequence = 0;

  /**
   * Create a new InputMessage with an auto-generated client tick and sequence number.
   *
   * <p>The client tick is automatically generated by the {@link ECSManagement ECSManagment} and
   * should not be set manually.
   *
   * <p>The sequence number is automatically incremented and should not be set manually. It uses a
   * static value to ensure that each message from the same client has a unique sequence number.
   *
   * @param action the action (e.g., move, move path, cast skill, interact)
   * @param point the point (e.g., move path, cast skill, interact)
   */
  public InputMessage(Action action, Point point) {
    this(
        Game.network().session().sessionId(),
        Game.currentTick(),
        incrementAndGetSequence(),
        action,
        point);
  }

  /**
   * Create a new InputMessage with an auto-generated client tick and sequence number.
   *
   * <p>The client tick is automatically generated by the {@link ECSManagement ECSManagment} and
   * should not be set manually.
   *
   * <p>The sequence number is automatically incremented and should not be set manually. It uses a
   * static value to ensure that each message from the same client has a unique sequence number.
   *
   * @param action the action (e.g., move, move path, cast skill, interact)
   * @param vec2 the point (e.g., move path, cast skill, interact)
   */
  public InputMessage(Action action, Vector2 vec2) {
    this(
        Game.network().session().sessionId(),
        Game.currentTick(),
        incrementAndGetSequence(),
        action,
        new Point(vec2.x(), vec2.y()));
  }

  /**
   * Increment and return the current sequence number. Wraps around using full 16-bit range. Uses
   * signed short (-32768 to 32767) to represent unsigned 0-65535.
   *
   * @return the incremented sequence number
   */
  private static short incrementAndGetSequence() {
    // Increment and wrap using full 16-bit range (natural overflow from 32767 to -32768)
    currentSequence++;
    return currentSequence;
  }

  /**
   * Reset the sequence number to 0. Should be called when a new game session starts.
   *
   * <p>This is important to ensure that sequence numbers are unique within a session and do not
   * carry over from previous sessions.
   */
  public static void resetSequence() {
    LOGGER.info("Resetting InputMessage sequence number to 0");
    currentSequence = 0;
  }

  /**
   * The action types for player input.
   *
   * <p>Defines the various actions a player can perform, such as moving, casting skills, and
   * interacting with objects.
   */
  public enum Action {
    /** Move to a specific {@link core.utils.Direction direction}. */
    MOVE(0, false),
    /** Cast a skill towards or at a specific {@link core.utils.Point point}. */
    CAST_SKILL(1, false),
    /** Interact with an object at a specific {@link core.utils.Point point}. */
    INTERACT(2, false),
    /** Switch to the next skill in the player's skill set. */
    NEXT_SKILL(3, false),
    /** Switch to the previous skill in the player's skill set. */
    PREV_SKILL(4, false),
    /**
     * Drop a specified item from the inventory.
     *
     * <p>The point x coordinate represents the inventory slot index of the item to be dropped.
     */
    INV_DROP(5, true),
    /**
     * Move an item within the inventory.
     *
     * <p>The point x coordinate represents the source inventory slot index, and the point y
     * coordinate represents the destination inventory slot index.
     */
    INV_MOVE(6, true),
    /**
     * Uses the item in the specified inventory slot.
     *
     * <p>The point x coordinate represents the inventory slot index of the item to be used.
     */
    INV_USE(7, true),
    /** Toggle the visibility of the inventory UI. */
    TOGGLE_INVENTORY(8, true);

    private final byte value;
    private final boolean ignorePause;

    /**
     * Constructor for Action enum.
     *
     * @param value the byte value representing the action
     * @param ignorePause whether this action should ignore game pause state
     */
    Action(int value, boolean ignorePause) {
      this.value = (byte) value;
      this.ignorePause = ignorePause;
    }

    /**
     * Get the byte value of the action.
     *
     * @return the byte value representing the action
     */
    public byte value() {
      return value;
    }

    /**
     * Check if the action ignores the game pause state.
     *
     * @return true if the action ignores pause, false otherwise
     */
    public boolean ignorePause() {
      return ignorePause;
    }
  }
}
