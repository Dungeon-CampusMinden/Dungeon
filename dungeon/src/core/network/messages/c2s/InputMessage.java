package core.network.messages.c2s;

import core.Game;
import core.network.messages.NetworkMessage;
import core.utils.Point;
import java.io.Serial;
import org.slf4j.LoggerFactory;

/**
 * Clientâ†’server: Player input (e.g., movement, skill use, interaction).
 *
 * @param clientTick the client tick when the input was generated
 * @param sequence the sequence number of this input message (monotonically increasing per client)
 * @param action the action (e.g., move, move path, cast skill, interact)
 * @param point the point (e.g., move path, cast skill, interact) Can be null depending on action
 * @param clientId the client ID (set by server upon receipt)
 */
public record InputMessage(
    int clientTick,
    int sequence,
    Action action,
    Point point, // Optional, depending on action
    long clientTimeMs, // Optional, only needed for latency calculation
    // Server fields:
    int clientId // Set by server upon receipt
    ) implements NetworkMessage {
  @Serial private static final long serialVersionUID = 1L;
  private static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(InputMessage.class);

  private static int currentSequence = 0;

  /**
   * Create a new InputMessage with an auto-generated client tick and sequence number.
   *
   * <p>The client tick is automatically generated by the {@link core.game.ECSManagment
   * ECSManagment} and should not be set manually.
   *
   * <p>The sequence number is automatically incremented and should not be set manually. It uses a
   * static value to ensure that each message from the same client has a unique sequence number.
   *
   * @param action the action (e.g., move, move path, cast skill, interact)
   * @param point the point (e.g., move path, cast skill, interact
   */
  public InputMessage(Action action, Point point) {
    this(
        Game.currentTick(),
        incrementAndGetSequence(),
        action,
        point,
        System.currentTimeMillis(),
        0);
  }

  /**
   * Increment and return the current sequence number. Wraps around at Integer.MAX_VALUE.
   *
   * @return the incremented sequence number
   */
  private static int incrementAndGetSequence() {
    currentSequence = (currentSequence + 1) % Integer.MAX_VALUE;
    return currentSequence;
  }

  /**
   * Reset the sequence number to 0. Should be called when a new game session starts.
   *
   * <p>This is important to ensure that sequence numbers are unique within a session and do not
   * carry over from previous sessions.
   */
  public static void resetSequence() {
    LOGGER.info("Resetting InputMessage sequence number to 0");
    currentSequence = 0;
  }

  public enum Action {
    MOVE(0),
    MOVE_PATH(1),
    CAST_SKILL(2),
    INTERACT(3),
    NEXT_SKILL(4),
    PREV_SKILL(5);

    private final byte value;

    Action(int value) {
      this.value = (byte) value;
    }

    public byte value() {
      return value;
    }
  }
}
