package core.network.messages.c2s;

import core.Game;
import core.game.ECSManagement;
import core.network.messages.NetworkMessage;
import core.utils.Point;
import core.utils.Vector2;
import core.utils.logging.DungeonLogger;
import java.util.Objects;

/**
 * Clientâ†’server: Player input (e.g., movement, skill use, interaction).
 *
 * @param sessionId the session ID of the client sending the input
 * @param clientTick the client tick when the input was generated
 * @param sequence the sequence number of this input message (monotonically increasing per client)
 * @param action the action (e.g., move, cast skill, interact)
 * @param payload the typed payload for the action
 */
public record InputMessage(
    // HEADER
    int sessionId,
    int clientTick,
    short sequence,
    // PAYLOAD
    Action action,
    Payload payload)
    implements NetworkMessage {
  private static final DungeonLogger LOGGER = DungeonLogger.getLogger(InputMessage.class);

  private static short currentSequence = 0;

  /**
   * Creates a new input message and validates the payload for the action.
   *
   * @param sessionId the session ID of the client sending the input
   * @param clientTick the client tick when the input was generated
   * @param sequence the sequence number of this input message (monotonically increasing per client)
   * @param action the action to execute
   * @param payload the typed payload for the action
   */
  public InputMessage {
    Objects.requireNonNull(action, "action");
    Objects.requireNonNull(payload, "payload");
    validatePayload(action, payload);
  }

  /**
   * Create a new InputMessage with an auto-generated client tick and sequence number.
   *
   * <p>The client tick is automatically generated by the {@link ECSManagement ECSManagment} and
   * should not be set manually.
   *
   * <p>The sequence number is automatically incremented and should not be set manually. It uses a
   * static value to ensure that each message from the same client has a unique sequence number.
   *
   * @param action the action to execute
   * @param payload the typed payload for the action
   */
  public InputMessage(Action action, Payload payload) {
    this(
        Game.network().session().sessionId(),
        Game.currentTick(),
        incrementAndGetSequence(),
        action,
        payload);
  }

  /**
   * Creates a move input message.
   *
   * @param direction the movement direction vector
   * @return the created input message
   */
  public static InputMessage move(Vector2 direction) {
    return new InputMessage(Action.MOVE, new Move(direction));
  }

  /**
   * Creates a cast skill input message.
   *
   * @param target the target point
   * @param mainSkill whether to cast the main skill (true) or second skill (false)
   * @return the created input message
   */
  public static InputMessage castSkill(Point target, boolean mainSkill) {
    return new InputMessage(Action.CAST_SKILL, new CastSkill(target, mainSkill));
  }

  /**
   * Creates an interact input message.
   *
   * @param target the interaction point
   * @return the created input message
   */
  public static InputMessage interact(Point target) {
    return new InputMessage(Action.INTERACT, new Interact(target));
  }

  /**
   * Creates a next skill input message.
   *
   * @param mainSkill whether to switch the main skill (true) or second skill (false)
   * @return the created input message
   */
  public static InputMessage nextSkill(boolean mainSkill) {
    return new InputMessage(Action.NEXT_SKILL, new SkillChange(true, mainSkill));
  }

  /**
   * Creates a previous skill input message.
   *
   * @param mainSkill whether to switch the main skill (true) or second skill (false)
   * @return the created input message
   */
  public static InputMessage prevSkill(boolean mainSkill) {
    return new InputMessage(Action.PREV_SKILL, new SkillChange(false, mainSkill));
  }

  /**
   * Creates an inventory drop input message.
   *
   * @param slotIndex the slot index to drop from
   * @return the created input message
   */
  public static InputMessage invDrop(int slotIndex) {
    return new InputMessage(Action.INV_DROP, new InventoryDrop(slotIndex));
  }

  /**
   * Creates an inventory move input message.
   *
   * @param fromSlot the source slot index
   * @param toSlot the target slot index
   * @return the created input message
   */
  public static InputMessage invMove(int fromSlot, int toSlot) {
    return new InputMessage(Action.INV_MOVE, new InventoryMove(fromSlot, toSlot));
  }

  /**
   * Creates an inventory use input message.
   *
   * @param slotIndex the slot index to use
   * @return the created input message
   */
  public static InputMessage invUse(int slotIndex) {
    return new InputMessage(Action.INV_USE, new InventoryUse(slotIndex));
  }

  /**
   * Creates a toggle inventory input message.
   *
   * @return the created input message
   */
  public static InputMessage toggleInventory() {
    return new InputMessage(Action.TOGGLE_INVENTORY, new ToggleInventory());
  }

  /**
   * Increment and return the current sequence number. Wraps around using full 16-bit range. Uses
   * signed short (-32768 to 32767) to represent unsigned 0-65535.
   *
   * @return the incremented sequence number
   */
  private static short incrementAndGetSequence() {
    // Increment and wrap using full 16-bit range (natural overflow from 32767 to -32768)
    currentSequence++;
    return currentSequence;
  }

  /**
   * Reset the sequence number to 0. Should be called when a new game session starts.
   *
   * <p>This is important to ensure that sequence numbers are unique within a session and do not
   * carry over from previous sessions.
   */
  public static void resetSequence() {
    LOGGER.info("Resetting InputMessage sequence number to 0");
    currentSequence = 0;
  }

  /**
   * Returns the payload casted to the requested type.
   *
   * @param type the payload type
   * @param <T> the payload type
   * @return the payload as the requested type
   */
  public <T extends Payload> T payloadAs(Class<T> type) {
    Objects.requireNonNull(type, "type");
    if (!type.isInstance(payload)) {
      throw new IllegalArgumentException(
          "Expected payload of type "
              + type.getSimpleName()
              + " for action "
              + action
              + " but got "
              + payload.getClass().getSimpleName());
    }
    return type.cast(payload);
  }

  private static void validatePayload(Action action, Payload payload) {
    switch (action) {
      case MOVE -> requirePayload(action, payload, Move.class);
      case CAST_SKILL -> requirePayload(action, payload, CastSkill.class);
      case INTERACT -> requirePayload(action, payload, Interact.class);
      case NEXT_SKILL -> {
        SkillChange change = requirePayload(action, payload, SkillChange.class);
        if (!change.nextSkill()) {
          throw new IllegalArgumentException("NEXT_SKILL requires nextSkill=true");
        }
      }
      case PREV_SKILL -> {
        SkillChange change = requirePayload(action, payload, SkillChange.class);
        if (change.nextSkill()) {
          throw new IllegalArgumentException("PREV_SKILL requires nextSkill=false");
        }
      }
      case INV_DROP -> requirePayload(action, payload, InventoryDrop.class);
      case INV_MOVE -> requirePayload(action, payload, InventoryMove.class);
      case INV_USE -> requirePayload(action, payload, InventoryUse.class);
      case TOGGLE_INVENTORY -> requirePayload(action, payload, ToggleInventory.class);
    }
  }

  private static <T extends Payload> T requirePayload(
      Action action, Payload payload, Class<T> expectedType) {
    if (!expectedType.isInstance(payload)) {
      throw new IllegalArgumentException(
          "Action " + action + " requires payload " + expectedType.getSimpleName());
    }
    return expectedType.cast(payload);
  }

  /** Marker interface for input payloads. */
  public sealed interface Payload
      permits Move,
          CastSkill,
          Interact,
          SkillChange,
          InventoryDrop,
          InventoryMove,
          InventoryUse,
          ToggleInventory {}

  /** Payload for movement input. */
  public record Move(Vector2 direction) implements Payload {
    public Move {
      Objects.requireNonNull(direction, "direction");
    }
  }

  /** Payload for casting a skill. */
  public record CastSkill(Point target, boolean mainSkill) implements Payload {
    public CastSkill {
      Objects.requireNonNull(target, "target");
    }
  }

  /** Payload for interacting with a world point. */
  public record Interact(Point target) implements Payload {
    public Interact {
      Objects.requireNonNull(target, "target");
    }
  }

  /** Payload for switching skills. */
  public record SkillChange(boolean nextSkill, boolean mainSkill) implements Payload {}

  /** Payload for dropping an inventory item. */
  public record InventoryDrop(int slotIndex) implements Payload {}

  /** Payload for moving items between inventory slots. */
  public record InventoryMove(int fromSlot, int toSlot) implements Payload {}

  /** Payload for using an inventory item. */
  public record InventoryUse(int slotIndex) implements Payload {}

  /** Payload for toggling inventory visibility. */
  public record ToggleInventory() implements Payload {}

  /**
   * The action types for player input.
   *
   * <p>Defines the various actions a player can perform, such as moving, casting skills, and
   * interacting with objects.
   */
  public enum Action {
    /** Move in a specific {@link core.utils.Direction direction}. */
    MOVE(0, false),
    /** Cast the main skill towards or at a specific {@link core.utils.Point point}. */
    CAST_SKILL(1, false),
    /** Interact with an object at a specific {@link core.utils.Point point}. */
    INTERACT(2, false),
    /** Switch to the next main skill in the player's skill set. */
    NEXT_SKILL(3, false),
    /** Switch to the previous main skill in the player's skill set. */
    PREV_SKILL(4, false),
    /** Drop a specified item from the inventory. */
    INV_DROP(5, true),
    /** Move an item within the inventory. */
    INV_MOVE(6, true),
    /** Use the item in the specified inventory slot. */
    INV_USE(7, true),
    /** Toggle the visibility of the inventory UI. */
    TOGGLE_INVENTORY(8, true);

    private final byte value;
    private final boolean ignorePause;

    /**
     * Constructor for Action enum.
     *
     * @param value the byte value representing the action
     * @param ignorePause whether this action should ignore game pause state
     */
    Action(int value, boolean ignorePause) {
      this.value = (byte) value;
      this.ignorePause = ignorePause;
    }

    /**
     * Get the byte value of the action.
     *
     * @return the byte value representing the action
     */
    public byte value() {
      return value;
    }

    /**
     * Check if the action ignores the game pause state.
     *
     * @return true if the action ignores pause, false otherwise
     */
    public boolean ignorePause() {
      return ignorePause;
    }
  }
}
