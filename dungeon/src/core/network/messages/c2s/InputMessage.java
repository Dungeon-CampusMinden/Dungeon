package core.network.messages.c2s;

import core.Game;
import core.network.messages.NetworkMessage;
import core.utils.Point;
import core.utils.logging.DungeonLogger;
import java.io.Serial;

/**
 * Clientâ†’server: Player input (e.g., movement, skill use, interaction).
 *
 * @param sessionId the session ID of the client sending the input
 * @param clientTick the client tick when the input was generated
 * @param sequence the sequence number of this input message (monotonically increasing per client)
 * @param action the action (e.g., move, move path, cast skill, interact)
 * @param point the point (e.g., move path, cast skill, interact) Can be null depending on action
 */
public record InputMessage(
    // HEADER
    int sessionId,
    int clientTick,
    short sequence,
    // PAYLOAD
    Action action,
    Point point // Optional, depending on action
    ) implements NetworkMessage {
  @Serial private static final long serialVersionUID = 1L;
  private static final DungeonLogger LOGGER = DungeonLogger.getLogger(InputMessage.class);

  private static short currentSequence = 0;

  /**
   * Create a new InputMessage with an auto-generated client tick and sequence number.
   *
   * <p>The client tick is automatically generated by the {@link core.game.ECSManagment
   * ECSManagment} and should not be set manually.
   *
   * <p>The sequence number is automatically incremented and should not be set manually. It uses a
   * static value to ensure that each message from the same client has a unique sequence number.
   *
   * @param action the action (e.g., move, move path, cast skill, interact)
   * @param point the point (e.g., move path, cast skill, interact
   */
  public InputMessage(Action action, Point point) {
    this(
        Game.network().session().sessionId(),
        Game.currentTick(),
        incrementAndGetSequence(),
        action,
        point);
  }

  /**
   * Increment and return the current sequence number. Wraps around at Short.MAX_VALUE.
   *
   * @return the incremented sequence number
   */
  private static short incrementAndGetSequence() {
    currentSequence = (short) ((currentSequence + 1) % Short.MAX_VALUE);
    return currentSequence;
  }

  /**
   * Reset the sequence number to 0. Should be called when a new game session starts.
   *
   * <p>This is important to ensure that sequence numbers are unique within a session and do not
   * carry over from previous sessions.
   */
  public static void resetSequence() {
    LOGGER.info("Resetting InputMessage sequence number to 0");
    currentSequence = 0;
  }

  public enum Action {
    MOVE(0),
    MOVE_PATH(1),
    CAST_SKILL(2),
    INTERACT(3),
    NEXT_SKILL(4),
    PREV_SKILL(5);

    private final byte value;

    Action(int value) {
      this.value = (byte) value;
    }

    public byte value() {
      return value;
    }
  }
}
