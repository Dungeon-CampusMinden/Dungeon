package core.network.messages.c2s;

import core.Game;
import core.game.ECSManagement;
import core.network.messages.NetworkMessage;
import core.utils.Point;
import core.utils.Vector2;
import core.utils.logging.DungeonLogger;
import java.io.Serial;

/**
 * Clientâ†’server: Player input (e.g., movement, skill use, interaction).
 *
 * @param sessionId the session ID of the client sending the input
 * @param clientTick the client tick when the input was generated
 * @param sequence the sequence number of this input message (monotonically increasing per client)
 * @param action the action (e.g., move, move path, cast skill, interact)
 * @param point the point (e.g., move path, cast skill, interact) Can be null depending on action
 */
public record InputMessage(
    // HEADER
    int sessionId,
    int clientTick,
    short sequence,
    // PAYLOAD
    Action action,
    Point point // Optional, depending on action
    ) implements NetworkMessage {
  @Serial private static final long serialVersionUID = 1L;
  private static final DungeonLogger LOGGER = DungeonLogger.getLogger(InputMessage.class);

  private static short currentSequence = 0;

  /**
   * Create a new InputMessage with an auto-generated client tick and sequence number.
   *
   * <p>The client tick is automatically generated by the {@link ECSManagement ECSManagment} and
   * should not be set manually.
   *
   * <p>The sequence number is automatically incremented and should not be set manually. It uses a
   * static value to ensure that each message from the same client has a unique sequence number.
   *
   * @param action the action (e.g., move, move path, cast skill, interact)
   * @param point the point (e.g., move path, cast skill, interact)
   */
  public InputMessage(Action action, Point point) {
    this(
        Game.network().session().sessionId(),
        Game.currentTick(),
        incrementAndGetSequence(),
        action,
        point);
  }

  /**
   * Create a new InputMessage with an auto-generated client tick and sequence number.
   *
   * <p>The client tick is automatically generated by the {@link ECSManagement ECSManagment} and
   * should not be set manually.
   *
   * <p>The sequence number is automatically incremented and should not be set manually. It uses a
   * static value to ensure that each message from the same client has a unique sequence number.
   *
   * @param action the action (e.g., move, move path, cast skill, interact)
   * @param vec2 the point (e.g., move path, cast skill, interact)
   */
  public InputMessage(Action action, Vector2 vec2) {
    this(
        Game.network().session().sessionId(),
        Game.currentTick(),
        incrementAndGetSequence(),
        action,
        new Point(vec2.x(), vec2.y()));
  }

  /**
   * Increment and return the current sequence number. Wraps around at Short.MAX_VALUE.
   *
   * @return the incremented sequence number
   */
  private static short incrementAndGetSequence() {
    currentSequence = (short) ((currentSequence + 1) % Short.MAX_VALUE);
    return currentSequence;
  }

  /**
   * Reset the sequence number to 0. Should be called when a new game session starts.
   *
   * <p>This is important to ensure that sequence numbers are unique within a session and do not
   * carry over from previous sessions.
   */
  public static void resetSequence() {
    LOGGER.info("Resetting InputMessage sequence number to 0");
    currentSequence = 0;
  }

  /**
   * The action types for player input.
   *
   * <p>Defines the various actions a player can perform, such as moving, casting skills, and
   * interacting with objects.
   */
  public enum Action {
    /** Move to a specific {@link core.utils.Direction direction}. */
    MOVE(0),
    /** Cast a skill towards or at a specific {@link core.utils.Point point}. */
    CAST_SKILL(1),
    /** Interact with an object at a specific {@link core.utils.Point point}. */
    INTERACT(2),
    /** Switch to the next skill in the player's skill set. */
    NEXT_SKILL(3),
    /** Switch to the previous skill in the player's skill set. */
    PREV_SKILL(4);

    private final byte value;

    /**
     * Constructor for Action enum.
     *
     * @param value the byte value representing the action
     */
    Action(int value) {
      this.value = (byte) value;
    }

    /**
     * Get the byte value of the action.
     *
     * @return the byte value representing the action
     */
    public byte value() {
      return value;
    }
  }
}
